package tui

import (
	"fmt"
	"os/exec"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/howell-aikit/aiflow/internal/config"
	"github.com/howell-aikit/aiflow/internal/state"
)

// CompletionAction represents the user's choice on completion
type CompletionAction int

const (
	CompletionCreatePR CompletionAction = iota
	CompletionMergeDirect
	CompletionKeepBranch
)

// CompletionModel handles the completion options screen
type CompletionModel struct {
	cfg          *config.Config
	run          *state.Run
	store        *state.Store
	selectedItem int
	actions      []CompletionAction
	prURL        string
	err          error
	done         bool
	processing   bool
}

// NewCompletionModel creates a new completion model
func NewCompletionModel(cfg *config.Config, run *state.Run, store *state.Store) CompletionModel {
	return CompletionModel{
		cfg:   cfg,
		run:   run,
		store: store,
		actions: []CompletionAction{
			CompletionCreatePR,
			CompletionMergeDirect,
			CompletionKeepBranch,
		},
	}
}

// Update handles messages for completion model
func (m CompletionModel) Update(msg tea.Msg) (CompletionModel, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		if m.processing {
			return m, nil
		}
		switch msg.String() {
		case "up", "k":
			if m.selectedItem > 0 {
				m.selectedItem--
			}
		case "down", "j":
			if m.selectedItem < len(m.actions)-1 {
				m.selectedItem++
			}
		case "enter":
			return m.handleAction(m.actions[m.selectedItem])
		case "q", "esc":
			return m, tea.Quit
		}

	case prCreatedMsg:
		m.processing = false
		if msg.err != nil {
			m.err = msg.err
		} else {
			m.prURL = msg.url
		}
		return m, nil

	case mergeCompleteMsg:
		m.processing = false
		if msg.err != nil {
			m.err = msg.err
		} else {
			m.done = true
		}
		return m, nil
	}
	return m, nil
}

func (m CompletionModel) handleAction(action CompletionAction) (CompletionModel, tea.Cmd) {
	switch action {
	case CompletionCreatePR:
		m.processing = true
		return m, m.createPR()

	case CompletionMergeDirect:
		m.processing = true
		return m, m.mergeDirect()

	case CompletionKeepBranch:
		m.done = true
		return m, tea.Quit
	}
	return m, nil
}

// Messages
type prCreatedMsg struct {
	url string
	err error
}

type mergeCompleteMsg struct {
	err error
}

func (m CompletionModel) createPR() tea.Cmd {
	return func() tea.Msg {
		// Get current branch name
		branchCmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
		branchCmd.Dir = m.run.WorktreePath
		branchOutput, err := branchCmd.Output()
		if err != nil {
			return prCreatedMsg{err: fmt.Errorf("failed to get branch: %w", err)}
		}
		branch := strings.TrimSpace(string(branchOutput))

		// Push branch to remote
		pushCmd := exec.Command("git", "push", "-u", "origin", branch)
		pushCmd.Dir = m.run.WorktreePath
		if output, err := pushCmd.CombinedOutput(); err != nil {
			return prCreatedMsg{err: fmt.Errorf("failed to push: %w: %s", err, string(output))}
		}

		// Create PR using gh CLI
		title := m.run.FeatureDesc
		if len(title) > 72 {
			title = title[:69] + "..."
		}

		prCmd := exec.Command("gh", "pr", "create",
			"--title", title,
			"--body", fmt.Sprintf("## Summary\n\n%s\n\n---\nGenerated by aiflow", m.run.FeatureDesc),
		)
		prCmd.Dir = m.run.WorktreePath
		output, err := prCmd.CombinedOutput()
		if err != nil {
			return prCreatedMsg{err: fmt.Errorf("failed to create PR: %w: %s", err, string(output))}
		}

		// Extract PR URL from output
		url := strings.TrimSpace(string(output))
		return prCreatedMsg{url: url}
	}
}

func (m CompletionModel) mergeDirect() tea.Cmd {
	return func() tea.Msg {
		// Get current branch
		branchCmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
		branchCmd.Dir = m.run.WorktreePath
		branchOutput, err := branchCmd.Output()
		if err != nil {
			return mergeCompleteMsg{err: fmt.Errorf("failed to get branch: %w", err)}
		}
		branch := strings.TrimSpace(string(branchOutput))

		// Checkout base branch
		checkoutCmd := exec.Command("git", "checkout", m.run.BaseBranch)
		checkoutCmd.Dir = m.run.WorktreePath
		if output, err := checkoutCmd.CombinedOutput(); err != nil {
			return mergeCompleteMsg{err: fmt.Errorf("failed to checkout %s: %w: %s", m.run.BaseBranch, err, string(output))}
		}

		// Merge feature branch
		mergeCmd := exec.Command("git", "merge", branch, "--no-ff", "-m", fmt.Sprintf("Merge aiflow: %s", m.run.FeatureDesc))
		mergeCmd.Dir = m.run.WorktreePath
		if output, err := mergeCmd.CombinedOutput(); err != nil {
			return mergeCompleteMsg{err: fmt.Errorf("failed to merge: %w: %s", err, string(output))}
		}

		return mergeCompleteMsg{}
	}
}

// View renders the completion screen
func (m CompletionModel) View() string {
	var b strings.Builder

	b.WriteString(titleStyle.Render("All Tasks Complete!"))
	b.WriteString("\n\n")

	b.WriteString(successStyle.Render("Feature implemented successfully"))
	b.WriteString("\n")
	b.WriteString(dimStyle.Render(TruncateString(m.run.FeatureDesc, 60)))
	b.WriteString("\n\n")

	// Show task summary
	completed := len(m.run.GetCompletedTasks())
	b.WriteString(fmt.Sprintf("Completed %d tasks\n", completed))
	b.WriteString(dimStyle.Render(fmt.Sprintf("Worktree: %s", m.run.WorktreePath)))
	b.WriteString("\n\n")

	if m.err != nil {
		b.WriteString(errorStyle.Render(fmt.Sprintf("Error: %v", m.err)))
		b.WriteString("\n\n")
	}

	if m.prURL != "" {
		b.WriteString(successStyle.Render("PR created:"))
		b.WriteString("\n")
		b.WriteString(infoStyle.Render(m.prURL))
		b.WriteString("\n\n")
		b.WriteString(dimStyle.Render("Press q to quit"))
		return boxStyle.Render(b.String())
	}

	if m.done {
		b.WriteString(successStyle.Render("Changes merged to " + m.run.BaseBranch))
		b.WriteString("\n\n")
		b.WriteString(dimStyle.Render("Press q to quit"))
		return boxStyle.Render(b.String())
	}

	if m.processing {
		b.WriteString("Processing...\n")
		return boxStyle.Render(b.String())
	}

	b.WriteString("What would you like to do?\n\n")

	actionLabels := map[CompletionAction]string{
		CompletionCreatePR:    "Create Pull Request",
		CompletionMergeDirect: "Merge directly to " + m.run.BaseBranch,
		CompletionKeepBranch:  "Keep on branch (review later)",
	}

	actionDescs := map[CompletionAction]string{
		CompletionCreatePR:    "Push branch and open PR for review",
		CompletionMergeDirect: "Merge changes without PR",
		CompletionKeepBranch:  "Exit and keep changes in worktree",
	}

	for i, action := range m.actions {
		prefix := "  "
		style := normalStyle
		if i == m.selectedItem {
			prefix = "> "
			style = selectedStyle
		}

		label := actionLabels[action]
		b.WriteString(style.Render(fmt.Sprintf("%s%s", prefix, label)))
		b.WriteString("\n")

		if i == m.selectedItem {
			b.WriteString(dimStyle.Render(fmt.Sprintf("    %s", actionDescs[action])))
			b.WriteString("\n")
		}
	}

	b.WriteString("\n")
	b.WriteString(dimStyle.Render("↑/↓ select • Enter to confirm • q to quit"))

	return boxStyle.Render(b.String())
}
